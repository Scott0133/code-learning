/*不使用强制类型转换，实现指针 p 的地址加 1 是不可能的。让我解释一下为什么：
指针算术运算规则：在 C 语言中，指针的算术运算遵循类型的大小。例如，如果 p 是一个 int * 类型的指针，那么 p + 1 将使 p 向后移动一个整数的大小（通常是 4 字节）。这是因为指针的偏移量取决于指针类型的大小。
对齐要求：指针的地址必须满足特定的对齐要求。例如，int 类型通常需要 4 字节对齐。如果你试图将 p 的地址加 1，那么它将不再满足对齐要求，这可能导致未定义行为。
类型转换的问题：虽然你可以使用类型转换来实现指针地址加 1，但这并不是一个推荐的做法。这样的操作可能会导致代码不可移植，且容易出错。
因此，如果你想让指针 p 的地址加 1，最好的做法是使用强制类型转换，如我之前提到的 (int *)((char *)p + 1)。但请注意，这样的操作可能会带来潜在的问题，因此在实际编程中应该谨慎使用。
*/
#include<stdio.h>
int main()
{
    int a = 10;
    int *p;
    p = &a;
    printf("value of p is %d\n", p);
    p = p + 1;
    printf("value of p is %d\n", p);
    p = (int *)((char *)p + 1);         //这里我们先将 p 转换为 char * 类型，然后再加 1，以确保只移动一个字节的大小。请注意，这样的操作可能会导致未定义行为，因为它不符合指针的对齐要求。
    printf("value of p is %d\n", p);

}